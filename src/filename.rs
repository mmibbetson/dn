use chrono::Local;

#[derive(Clone)]
pub struct FilenameDetails {
    title_arg: Option<String>,
    signature_arg: Option<String>,
    keywords_arg: Option<String>,
    extension_arg: Option<String>,
}

#[derive(PartialEq)]
pub enum Segment {
    Identifier,
    Signature,
    Title,
    Keywords,
    Extension,
}

const SEGMENT_SEPARATORS: [char; 4] = ['=', '-', '_', '.'];
// TODO: In the future, illegal characters should be configurable by the user.
const ILLEGAL_CHARACTERS: [char; 33] = [
    ' ', '[', ']', '{', '}', '(', ')', '!', '@', '#', '$', '%', '^', '&', '*', '+', '\'', '\\',
    '"', '?', ',', '.', '|', ';', ':', '~', '`', '‘', '’', '“', '”', '/', '*',
];

// TODO: This should be configurable by the user.
const DEFAULT_FILE_EXTENSION: &str = "txt";

pub fn get_filename(filename_details: FilenameDetails, order: &[Segment; 5]) -> String {
    let identifier = format_identifier(order[0] == Segment::Identifier);
    let signature = format_segment(filename_details.signature_arg, "==".to_string());
    let title = format_title(filename_details.title_arg, "--".to_string());
    let keywords = format_keywords(filename_details.keywords_arg, "__".to_string());
    let extension = format_extension(
        Some(filename_details.extension_arg.unwrap_or("txt".to_string())),
        ".".to_string(),
    );

    order
        .iter()
        .map(|segment| match segment {
            Segment::Identifier => identifier.clone(),
            Segment::Signature => signature.clone().unwrap_or_default(),
            Segment::Title => title.clone(),
            Segment::Keywords => keywords.clone().unwrap_or_default(),
            Segment::Extension => extension.clone(),
        })
        .collect::<Vec<String>>()
        .concat()
}

/// Generate a formatted identifier segment by getting the local time.
fn format_identifier(is_first: bool) -> String {
    let time = Local::now().format("%Y%m%dT%H%M%S").to_string();

    if is_first {
        time
    } else {
        format!("@@{}", time)
    }
}

/// Generate a formatted non-identifier segment.
fn format_segment(segment: Option<String>, prefix: String) -> Option<String> {
    segment.map(|seg| process_segment(seg, prefix))
}

fn process_segment(segment: String, prefix: String) -> String {
    let out = segment
        .to_lowercase()
        .split(prefix.chars().nth(0).unwrap())
        .map(sanitise_segment)
        .collect::<Vec<String>>()
        .join(prefix.get(0..1).unwrap());

    format!("{}{}", prefix, out)
}

fn sanitise_segment(segment: &str) -> String {
    segment
        .chars()
        .filter(|c| !SEGMENT_SEPARATORS.contains(c))
        .filter(|c| !ILLEGAL_CHARACTERS.contains(c))
        .collect()
}

// Tests
// TODO: These tests were generated by an LLM, they need to be properly reviewed and adjusted.
// TODO: Probably need to expand them as well.

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    // Helper function to create a predictable timestamp for testing
    fn get_mock_time() -> String {
        Local.with_ymd_and_hms(2024, 1, 1, 12, 0, 0)
            .unwrap()
            .format("%Y%m%dT%H%M%S")
            .to_string()
    }

    #[test]
    fn test_basic_filename_generation() {
        let details = FilenameDetails {
            title_arg: Some("My Document".to_string()),
            signature_arg: None,
            keywords_arg: None,
            extension_arg: None,
        };
        
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        assert!(result.contains("--mydocument"));
        assert!(result.ends_with(".txt"));
    }

    #[test]
    fn test_all_segments() {
        let details = FilenameDetails {
            title_arg: Some("Test Title".to_string()),
            signature_arg: Some("Author Name".to_string()),
            keywords_arg: Some("key1-key2".to_string()),
            extension_arg: Some("md".to_string()),
        };
        
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        assert!(result.contains("==authorname"));
        assert!(result.contains("--testtitle"));
        assert!(result.contains("__key1key2"));
        assert!(result.ends_with(".md"));
    }

    #[test]
    fn test_identifier_positioning() {
        let details = FilenameDetails {
            title_arg: Some("Test".to_string()),
            signature_arg: None,
            keywords_arg: None,
            extension_arg: None,
        };
        
        // Identifier first
        let order1 = [
            Segment::Identifier,
            Segment::Title,
            Segment::Signature,
            Segment::Keywords,
            Segment::Extension,
        ];
        let result1 = get_filename(details.clone(), &order1);
        
        // Identifier not first
        let order2 = [
            Segment::Title,
            Segment::Identifier,
            Segment::Signature,
            Segment::Keywords,
            Segment::Extension,
        ];
        let result2 = get_filename(details.clone(), &order2);
        
        assert!(!result1.contains("@@"));
        assert!(result2.contains("@@"));
    }

    #[test]
    fn test_illegal_characters() {
        let details = FilenameDetails {
            title_arg: Some("Test! @#$ Title".to_string()),
            signature_arg: Some("Author (Name)".to_string()),
            keywords_arg: Some("key1 & key2".to_string()),
            extension_arg: None,
        };
        
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        
        assert!(result.contains("--testtitle"));
        assert!(result.contains("==authorname"));
        assert!(result.contains("__key1key2"));
        assert!(!result.contains('!'));
        assert!(!result.contains('@'));
        assert!(!result.contains('&'));
        assert!(!result.contains('('));
    }

    #[test]
    fn test_empty_optional_segments() {
        let details = FilenameDetails {
            title_arg: None,
            signature_arg: None,
            keywords_arg: None,
            extension_arg: None,
        };
        
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        
        assert!(!result.contains("=="));
        assert!(!result.contains("--"));
        assert!(!result.contains("__"));
        assert!(result.ends_with(".txt"));
    }

    #[test]
    fn test_segment_separator_handling() {
        let details = FilenameDetails {
            title_arg: Some("first.second-third_fourth".to_string()),
            signature_arg: None,
            keywords_arg: None,
            extension_arg: None,
        };
        
        let order = [
            Segment::Identifier,
            Segment::Title,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        
        assert!(result.contains("--firstsecondthirdfourth"));
        assert!(!result.matches('.').count() > 1); // Only extension should have a dot
    }

    #[test]
    fn test_case_sensitivity() {
        let details = FilenameDetails {
            title_arg: Some("UPPERCASE".to_string()),
            signature_arg: Some("MixedCase".to_string()),
            keywords_arg: Some("CamelCase".to_string()),
            extension_arg: Some("PDF".to_string()),
        };
        
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];
        
        let result = get_filename(details, &order);
        
        assert!(result.contains("--uppercase"));
        assert!(result.contains("==mixedcase"));
        assert!(result.contains("__camelcase"));
        assert!(result.ends_with(".pdf"));
    }
}
