use chrono::Local;

#[derive(Clone)]
pub struct FilenameDetails {
    title_arg: String,
    signature_arg: Option<String>,
    keywords_arg: Option<String>,
    extension_arg: Option<String>,
}

#[derive(PartialEq)]
pub enum Segment {
    Identifier,
    Signature,
    Title,
    Keywords,
    Extension,
}

const SEGMENT_SEPARATORS: [char; 4] = ['=', '-', '_', '.'];
const ILLEGAL_CHARACTERS: [char; 33] = [
    ' ', '[', ']', '{', '}', '(', ')', '!', '@', '#', '$', '%', '^', '&', '*', '+', '\'', '\\',
    '"', '?', ',', '.', '|', ';', ':', '~', '`', '‘', '’', '“', '”', '/', '*',
];

pub fn get_filename(filename_details: FilenameDetails, order: &[Segment; 5]) -> String {
    let identifier_is_first = order[0] == Segment::Identifier;
    let identifier = format_identifier(identifier_is_first);
    let signature = format_signature(filename_details.signature_arg);
    let title = format_title(filename_details.title_arg);
    let keywords = format_keywords(filename_details.keywords_arg);
    let extension = format_extension(filename_details.extension_arg);

    order
        .iter()
        .map(|segment| match segment {
            Segment::Identifier => identifier.clone(),
            Segment::Signature => signature.clone().unwrap_or_default(),
            Segment::Title => title.clone(),
            Segment::Keywords => keywords.clone().unwrap_or_default(),
            Segment::Extension => extension.clone(),
        })
        .collect::<Vec<String>>()
        .concat()
}

fn format_identifier(is_first: bool) -> String {
    let time = Local::now().format("%Y%m%dT%H%M%S").to_string();

    if is_first {
        time
    } else {
        format!("@@{}", time)
    }
}

fn format_signature(signature: Option<String>) -> Option<String> {
    signature.map(|sig| process_segment(sig, "==".to_string()))
}

fn format_title(title: String) -> String {
    process_segment(title, "--".to_string())
}

fn format_keywords(keywords: Option<String>) -> Option<String> {
    keywords.map(|key| process_segment(key, "__".to_string()))
}

fn format_extension(extension: Option<String>) -> String {
    const DEFAULT_FILE_EXTENSION: &str = "txt";

    extension
        .map(|ext| process_segment(ext, ".".to_string()))
        .unwrap_or(DEFAULT_FILE_EXTENSION.to_owned())
}

fn process_segment(segment: String, prefix: String) -> String {
    let out = segment
        .to_lowercase()
        .split(prefix.chars().nth(0).unwrap())
        .map(sanitise_segment)
        .collect::<Vec<String>>()
        .join(prefix.get(0..1).unwrap());

    format!("{}{}", prefix, out)
}

fn sanitise_segment(segment: &str) -> String {
    segment
        .chars()
        .filter(|c| !SEGMENT_SEPARATORS.contains(c))
        .filter(|c| !ILLEGAL_CHARACTERS.contains(c))
        .collect()
}

// Tests
// TODO: These tests were generated by an LLM, they need to be properly reviewed and adjusted.
// TODO: Probably need to expand them as well.

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;
    use std::thread;

    fn create_basic_details() -> FilenameDetails {
        FilenameDetails {
            title_arg: "Test Title".to_string(),
            signature_arg: Some("Author".to_string()),
            keywords_arg: Some("key1_key2".to_string()),
            extension_arg: Some("md".to_string()),
        }
    }

    #[test]
    fn test_basic_filename_generation() {
        let details = create_basic_details();
        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];

        let result = get_filename(details, &order);
        
        // We can't test the exact timestamp, but we can verify the structure
        assert!(result.contains("==author"));
        assert!(result.contains("--test-title"));
        assert!(result.contains("__key1_key2"));
        assert!(result.ends_with(".md"));
    }

    #[test]
    fn test_identifier_format() {
        // Test identifier when first
        let id_first = format_identifier(true);
        assert_eq!(id_first.len(), 15); // YYYYMMDDTHHmmss
        assert!(!id_first.starts_with("@@"));

        // Test identifier when not first
        let id_not_first = format_identifier(false);
        assert_eq!(id_not_first.len(), 17); // @@YYYYMMDDTHHmmss
        assert!(id_not_first.starts_with("@@"));
    }

    #[test]
    fn test_signature_formatting() {
        assert_eq!(format_signature(None), None);
        assert_eq!(
            format_signature(Some("Test Author".to_string())),
            Some("==testauthor".to_string())
        );
        assert_eq!(
            format_signature(Some("Test=Author".to_string())),
            Some("==test=author".to_string())
        );
    }

    #[test]
    fn test_title_formatting() {
        assert_eq!(
            format_title("Hello World".to_string()),
            "--helloworld".to_string()
        );
        assert_eq!(
            format_title("Hello-World".to_string()),
            "--hello-world".to_string()
        );
        assert_eq!(
            format_title("UPPER-case".to_string()),
            "--upper-case".to_string()
        );
    }

    #[test]
    fn test_keywords_formatting() {
        assert_eq!(format_keywords(None), None);
        assert_eq!(
            format_keywords(Some("Tag1_Tag2".to_string())),
            Some("__tag1_tag2".to_string())
        );
        assert_eq!(
            format_keywords(Some("TAG_WITH_SPACES".to_string())),
            Some("__tagwithspaces".to_string())
        );
    }

    #[test]
    fn test_extension_formatting() {
        assert_eq!(format_extension(None), "txt".to_string());
        assert_eq!(
            format_extension(Some("MD".to_string())),
            ".md".to_string()
        );
        assert_eq!(
            format_extension(Some("tar.gz".to_string())),
            ".tar.gz".to_string()
        );
    }

    #[test]
    fn test_process_segment() {
        assert_eq!(
            process_segment("Hello=World".to_string(), "==".to_string()),
            "==hello=world"
        );
        assert_eq!(
            process_segment("Test-Case".to_string(), "--".to_string()),
            "--test-case"
        );
        assert_eq!(
            process_segment("Tag_One".to_string(), "__".to_string()),
            "__tag_one"
        );
        assert_eq!(
            process_segment("tar.gz".to_string(), ".".to_string()),
            ".tar.gz"
        );
    }

    #[test]
    fn test_process_segment_with_illegal_chars() {
        assert_eq!(
            process_segment("Hello@#$=World!".to_string(), "==".to_string()),
            "==hello=world"
        );
        assert_eq!(
            process_segment("Spaces Are Bad".to_string(), "--".to_string()),
            "--spacesarebad"
        );
    }

    #[test]
    fn test_process_segment_case_handling() {
        assert_eq!(
            process_segment("UPPER=case".to_string(), "==".to_string()),
            "==upper=case"
        );
        assert_eq!(
            process_segment("MiXeD-CaSe".to_string(), "--".to_string()),
            "--mixed-case"
        );
    }

    #[test]
    fn test_sanitise_segment() {
        assert_eq!(sanitise_segment("hello world!"), "helloworld");
        assert_eq!(sanitise_segment("test@#$%^&*"), "test");
        assert_eq!(sanitise_segment("with.dots.in.it"), "withdotsinit");
        assert_eq!(sanitise_segment("with-dashes-in-it"), "withdashesinit");
        assert_eq!(sanitise_segment("with_underscores_in_it"), "withunderscoresinit");
    }

    #[test]
    fn test_different_segment_orders() {
        let details = create_basic_details();
        
        let order1 = [
            Segment::Title,
            Segment::Identifier,
            Segment::Signature,
            Segment::Keywords,
            Segment::Extension,
        ];

        let order2 = [
            Segment::Identifier,
            Segment::Title,
            Segment::Signature,
            Segment::Keywords,
            Segment::Extension,
        ];

        let result1 = get_filename(details.clone(), &order1);
        let result2 = get_filename(details, &order2);

        // First result should have @@ before timestamp (since Identifier isn't first)
        assert!(result1.contains("@@"));
        // Second result shouldn't have @@ before timestamp
        assert!(!result2.contains("@@"));
    }

    #[test]
    fn test_timestamp_changes() {
        let details = create_basic_details();
        let order = [
            Segment::Identifier,
            Segment::Title,
            Segment::Extension,
            Segment::Signature,
            Segment::Keywords,
        ];

        let result1 = get_filename(details.clone(), &order);
        thread::sleep(Duration::from_secs(1));
        let result2 = get_filename(details, &order);

        assert_ne!(result1, result2, "Timestamps should be different");
    }

    #[test]
    fn test_missing_optional_components() {
        let details = FilenameDetails {
            title_arg: "Just Title".to_string(),
            signature_arg: None,
            keywords_arg: None,
            extension_arg: None,
        };

        let order = [
            Segment::Identifier,
            Segment::Signature,
            Segment::Title,
            Segment::Keywords,
            Segment::Extension,
        ];

        let result = get_filename(details, &order);
        
        assert!(!result.contains("=="));  // No signature
        assert!(result.contains("--justtitle"));
        assert!(!result.contains("__"));  // No keywords
        assert!(result.ends_with(".txt")); // Default extension
    }
}